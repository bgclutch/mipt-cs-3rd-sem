/*
   Запуск программы: ./chat <номер_терминала>
   Пример терминал 1: ./chat 1
   Пример терминал 2: ./chat 2
*/

#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> /* Добавлено для exit, atoi */

/* Базовое число для генерации ключа. 0xDEADBABE - шестнадцатеричная константа ("волшебное число") */
#define SHM_KEY_BASE 0xDEADBABE
/* Максимальный размер сегмента (1 << 20 = 1 Мб) */
#define SHM_MAXSIZE (1 << 20)
/* Задержка в микросекундах (10 мс) между проверками */
#define DELAY (10*1000)
/* Смещение для текста сообщения. Первые 100 байт отведены под ID отправителя */
#define OFFSET 100

int main(int argc, char *argv[])
{
    /* ЗАДАНИЕ 3: Передача номера терминала в параметре */
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <terminal_id>\n", argv[0]);
        exit(1);
    }
    /* Сохраняем ID текущего терминала (клиента) из аргументов */
    char *client_id = argv[1];

	printf(
		"--------------------\n"
		"SHM-Chat 0.2 (Fixed)\n"
		"--------------------\n"
		"Current Terminal ID: %s\n"
		"--------------------\n"
		"Enter chat room number (clients must use the same number):",
		client_id
	);

    /* Переменная для ключа разделяемой памяти */
	int room_number;

    /* ИСПРАВЛЕНИЕ ОШИБКИ: scanf требует адрес переменной (&room_number) */
	scanf("%d", &room_number);

    /* Очистка буфера ввода после scanf (чтобы fgets потом не прочитал оставшийся \n) */
    getchar();

    /* 2. Ключ формируется сложением базовой константы и введенного пользователем числа.
       Это позволяет создавать разные "комнаты" для чата.
       Пример: 0xDEADBABE + 1 = 0xDEADBABF */
	key_t shm_key = SHM_KEY_BASE + room_number;

	printf("--------------------\nChatting in room %d (Key: %x)\n\n", room_number, shm_key);

	/* Проверка существования сегмента (опционально, для отладки)
	   shmget параметры:
	   1. shm_key - ключ
	   2. 4096 - размер (для проверки достаточно маленького)
	   3. 0777 - права доступа (чтение/запись/исполнение для всех) */
	int shmid_test = shmget(shm_key, 4096, 0777);
	struct shmid_ds buf;

    /* ИСПРАВЛЕНИЕ ОШИБКИ: shmctl требует указатель на структуру (&buf)
       IPC_STAT - команда "получить информацию о сегменте" */
    if (shmid_test != -1) {
	    shmctl(shmid_test, IPC_STAT, &buf);
        /* Мы убрали проверку buf.shm_nattch > 2, чтобы разрешить многопользовательский чат */
    }

    /* Создаем дочерний процесс для разделения задач чтения и записи */
	pid_t childpid;
	if ((childpid = fork()) == -1)
	{
		perror("fork error");
        exit(1);
	}

	if(childpid == 0)
	{
		/* --- ДОЧЕРНИЙ ПРОЦЕСС: ЧТЕНИЕ (RECEIVER) --- */
        /* Отвечает за проверку общей памяти и вывод новых сообщений на экран */

		usleep(DELAY);

        /* Получаем доступ к разделяемой памяти.
           Если сегмент еще не создан родителем, shmget может вернуть ошибку,
           поэтому в реальном коде нужен цикл ожидания или создание в родителе ДО fork. */
		int shmid = shmget(shm_key, 4096, 0777);
        if (shmid == -1) {
             /* Если родитель не успел создать память, пробуем создать (или ждем) */
             usleep(DELAY * 5);
             shmid = shmget(shm_key, 4096, IPC_CREAT | 0777);
        }

        /* shmat - присоединяем память к указателю mem */
		char* mem = (char*)shmat(shmid, NULL, 0);

        /* Бесконечный цикл проверки сообщений */
		for(;;)
		{
            /* Логика чата:
               mem[0] != 0  -> В памяти есть сообщение (первый байт не пустой)
               strcmp != 0  -> Имя отправителя в памяти (mem) НЕ совпадает с моим ID
            */
			if (mem[0] != 0 && strcmp(mem, client_id) != 0)
			{
                /* Выводим сообщение: "ID: Текст" */
				printf("[%s] says: %s", mem, mem + OFFSET);

                /* Очищаем память, чтобы сообщение не печаталось бесконечно.
                   ВНИМАНИЕ: Это примитивная логика. В чате на >2 человек это приведет к тому,
                   что сообщение увидит только тот, кто первым его прочитает (race condition).
                   Для полноценного чата нужна более сложная структура (кольцевой буфер). */
				mem[0] = 0;
			}
			usleep(DELAY); /* Пауза, чтобы не грузить процессор */
		}
	} else
	{
		/* --- РОДИТЕЛЬСКИЙ ПРОЦЕСС: ЗАПИСЬ (SENDER) --- */
        /* Отвечает за чтение с клавиатуры и отправку в общую память */

        /* Создаем сегмент памяти, если его нет (IPC_CREAT) */
		int shmid = shmget(shm_key, 4096, IPC_CREAT | 0777);
		char* mem = (char*)shmat(shmid, NULL, 0);

        /* Инициализация памяти нулями при первом запуске */
        if (mem[0] != 0) {
            /* Если там мусор, можно почистить, но аккуратно */
        }

		usleep(20 * 1000);

		for(;;)
		{
            /* 1. Используем fgets вместо gets.
               gets небезопасен, так как не контролирует длину строки (buffer overflow).
               Пишем сообщение сразу со смещением OFFSET (100 байт) */
			if (fgets(mem + OFFSET, 1024, stdin) != NULL)
            {
                /* 3. Записываем номер терминала (client_id) в начало памяти (заголовок) */
                /* strncpy безопаснее strcpy. Копируем ID в начало буфера (до OFFSET) */
                strncpy(mem, client_id, OFFSET - 1);

                /* Ждем немного, пока получатель прочитает сообщение (примитивная синхронизация) */
                usleep(DELAY * 2);
            }
		}
	}
    return 0;
}